## Тестирование ПО (Software Testing)

![alt text](img/bugs.png)

### Жизненный цикл разработки ПО (SDLC)
Начнем как всегда издалека:

**SDLC (Software Development Life Cycle)** — это процесс, которому следуют для создания программного обеспечения в организациях. SDLC состоит из некоторого плана, который описывает, как разрабатывать, поддерживать, заменять и улучшать программное обеспечение. И в идеальном мире выглядит следующим образом:      

На каждом бывают даже свои должности (разработчик, тестировщик (QA-инженер), DevOps инженер, бизнес-аналитик, руководитель проекта, архитектор, тех. пис и т.д.)

<img src="img/sdlc.png" width ="300"><img src="img/sdlc2.png" width ="350">

* Этап 1: **Анализ требований**
    Перед тем как броситься в разработку нужно придумать что разрабатывать, это и есть самый первый этап. Если По уже придумано и мы уже не первый раз сюда попадаем, то обычно анализируют отзывы пользователей, требования к уже существующему ПО
* Этап 2: **Планирование**
    Далее нужно еще подумать (спланировать) реализацию без углубления в технические детали. Без планирования, бросившись сразу на решение задач можно потратить много времени просто так. Здесь думаем есть ли ресурсы на нашу идею, когда и кто будет делать
* Этап 3: **Дизайн/Проектирование архитектуры**
    Определяют дизайн/архитектуру ПО. Продумываются все компоненты ПО, т.к. их создание без наличия плана может привести с дорогостоящим исправлениям. Обычно здесь рисуют схемки, которые называются HLD (High Level Design) - схема с кратким описанием что и как и LLD (Low Level Design) - схема с деталями поглубже
* Этап 4: **Разработка продукта**
    Наконец-то кодинг - разработка, отладка и сборка ПО
* Этап 5: **Тестирование и интеграция продукта**
    ПО после разработки тестируется на ошибки и баги. Также здесь обычно тестируют ПО на известные уязвимости.  
* Этап 6: **Развертывание и обслуживание продуктов**
    Написание документации, развертывание у пользователей ПО, обслуживание

5 этап - есть этап тестирования ПО, по которому мы пробежимся в этой лекции

### Тестирование ПО

**Тестирование ПО** — это процесс проверки и подтверждения того, работает ли приложение так, как ожидалось, включает в себя выявление ошибок и неполадок, которые в будущем могут вызвать проблемы у пользователей приложения. Например, ПО с ошибками в самолетах/машинах и других средствах передвижения вряд ли приведут к чему-то хорошему. Много случаев в истории уже наблюдалось, такие ошибки приводят к финансовым или человеческим потерям (см. в гугле что-нибудь типа "software errors in history")    

Тестирование ПО разделяют на два типа:
- **Ручное тестирование (Manual)**
Ручное тестирование ПО - тестирование приложения ручками. Тестер напрямую взаимодействует с приложением и смотрит работает ли как надо. Если работает не как надо - есть баги, то заводит задачи на разработчиков. В любом случае дает фидбек (обратную связь)      
- **Автоматизированное тестирование (Automation)**
    Автоматизировать тестирование - значит написать код, в котором ожидаемые сценарии сравниваются с тем, что действительно получил пользователь. Простыми словами - тестировщик пишет код/скрипты, которые тестируют программу.

**Виды тестов**
https://www.atlassian.com/ru/continuous-delivery/software-testing/types-of-software-testing           

1. **Модульные тесты (Unit-тесты)**
Модульные тесты работают на очень низком уровне. Они заключаются в тестировании отдельных функций, компонентов или модулей, используемых в ПО. Модульные тесты обычно легковесны и выполняются быстро

1. **Интеграционные тесты (Integration)**
В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули, используемые приложением. Например, можно протестировать взаимодействие с базой данных. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения

1. **Функциональные тесты (Functional)**
В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.

Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

4. **Сквозные тесты (End to End или E2E)**
Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).

Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

5. **Приемочное тестирование (Acceptance)**
Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

6. **Тестирование производительности (performance)**
В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

7. **Smoke-тестирование**
Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.

Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).


### Фазы тестирования
Основные фазы тестирования (https://habr.com/ru/articles/549054/)

- **Pre-Alpha**: прототип, в котором всё ещё присутствует много ошибок и наверняка неполный функционал. Необходим для ознакомления с будущими возможностями программ.
- **Alpha**: является ранней версией программного продукта, тестирование которой проводится внутри фирмы-разработчика.
- **Beta**: практически готовый продукт, который разработан в первую очередь для тестирования конечными пользователями.
- **Release Candidate (RC)**: возможные ошибки в каждой из фичей уже устранены и разработчики выпускают версию на которой проводится регрессионное тестирование.
- **Release**: финальная версия программы, которая готова к использованию.

### Основы модульного тестирования


#### BDD

Как обычно выглядит работа разработчика? Обычно у нас есть некоторая задача/требование, увидев, которую мы сразу бежим и пишем код, который хоть как-то работает, а затем запускаем и смотрим как оно отрабатывает, чтобы понять что не написали какую-то не работающую хрень. Потом вероятнее всего ловим ошибку и идем назад в код смотреть что не так и так до тех пор пока не заработает наш код, примерно это выглядит так:      
![alt text](./img/not_bdd.png)       

Отсюда возникают некоторые неудобства, сначала написал что-то что хоть как-то работает, а потом пытаешься проверить работает ли оно или нет. Ничего не забыли ли добавить проверить..  Качество кода отсюда будет напрямую зависит от того как вы смогли протестировать свою программу. Никто не захочет пользоваться программой, которая будет работать медленно и/или не безопасно и постоянно вылетать      

Поэтому для повышения качества кода программисты довольно давно придумали немного иной метод разработки, что обозвали BDD - Behavior-driven development, дословно «разработка через поведение».       

![alt text](./img/bdd.png)

Если его сильно упростить, то суть следующая - мы сначала явно описываем все сценарии и поведение программы, а затем пишем код, который будет соответствовать этому поведению, т.е. получается что мы придумываем как протестировать программу, которой еще не существует       

Зачем этот BDD подход в разработке и в чем его плюсы? Почему мы сначала пишем тесты, а для них код? 
- Дело в том, что такая практика позволяет сфокусироваться на какой-то мелкой задаче и писать тот код, что решает только ее и не задумываться о том, что мой код должен решать сразу все мировые проблемы. Мой код должен решать этот тест и на этом все. 
- Написание требований и тестов покрывает также документацию кода, которую разработчики так не любят писать 

Есть конечно и минусы, например: разработка кода замедлится, т.к. сначала надо написать тесты.. 
В реальной корпоративной разработке BDD зануднее и безумнее чем я здесь описал, но суть примерно та же.        

BDD это ответвление от подхода TDD, где TDD - это когда требования запихивают в тесты (см. в гугле)       

Для BDD в корпорациях даже используется специальные языки "программирования", например есть такой язык Gherkin, позволяющий описать сценарии на разных естественных языках и даже с каким-нибудь питончиком (или фреймворком типа Cucumber https://cucumber.io/docs/) совместно запускать эти самые тесты.          

``` Gherkin
Given User is on Login Page
When User enters login 'user_login'
   And User enters password 'user_password'
Then ‘Welcome to our site’ message displayed
 
Допустим пользователь находится на странице логина
Когда пользователь вводит логин 'user_login'
   И пользователь вводит пароль 'user_password'
Тогда появляется сообщение ‘Welcome to our site’
```

Честно говоря, это прям что-то из другой вселенной и такое можно увидеть толкьо в очень крупных IT-компаниях.      

Картинка из https://cucumber.io/docs/       

![alt text](img/gherkin.png)       

#### Тесты - это тоже программа

Тесты - есть программа, чаще всего написанная на том же языке, на котором написан целевой код (Программы на Си обычно покрывают кодом на Си и т.д.)      

Все тесты довольно похожи друг на друга, поэтому была придумана типовая архитектура фреймворка для тестирования - xUnit. В самом паттерне xUnit довольно много разных определений, но я приведу самые главные, рассмотрим схему того как обычно выглядит тестовая программа:          

- Фикстура - некоторая конфигурация (настройки) тестирования. Например настройки в каком состоянии должна находиться система для тестирования   
- Arrange - подготовить входные данные
- Act - Отработка теста
- Assert - Проверка
- Formatter - форматирование в красивом для человека вида с результатами тестов
- Runner - тот, кто запускает программу    

![alt text](img/runner.png)      

![alt text](img/aaa.png)      

#### Попробуем написать свои тесты (используя C и CMocka)
![alt text](./img/prob.png)

##### Список фреймворков для разных Языков Программирования   

https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks

Для языка Си как и для других языков есть очень много разных фреймворков для тестирования, но мы рассмотрим пару примеров на элегантном CMocka. Ссылки на доки:    
- https://cmocka.org/
- https://cmocka.org/talks/cmocka_unit_testing_and_mocking.pdf
- https://api.cmocka.org/index.html

#### CMocka
##### Инсталляция

Например можно так:
```bash
sudo apt install libcmocka-dev
```

##### Линковка

При компиляции линкуем с библиотекой CMocka:
```bash
gcc test_sum.c example.c -lcmocka
gcc test_file.c file.c -lcmocka
```

#### Unit тесты на cmocka

Пару примеров с тестами:    

https://github.com/kruffka/C-Programming/blob/master/2024-2025/sw_testing/tests/test_example.c      

https://github.com/kruffka/C-Programming/blob/master/2024-2025/sw_testing/tests/test_file.c       

#### CMocka форматтер
```bash
CMOCKA_MESSAGE_OUTPUT=stdout ./test
CMOCKA_MESSAGE_OUTPUT=subunit ./test
CMOCKA_MESSAGE_OUTPUT=tap ./test
CMOCKA_MESSAGE_OUTPUT=xml ./test
```

#### Ctest форматтер

Ищем в гугле или у китайского кореша CMake и CTest


##### Function Mock в CMocka
https://api.cmocka.org/group__cmocka__mock.html


#### Code Coverage (Покрытие кода)

**Code Coverage** — это метрика покрытия кода, не метрика закрытия требований     

**Покрытие тестами на 100% != Качество кода**     
![alt text](img/coverage.png)

### CI/CD
https://habr.com/ru/companies/otus/articles/515078/      

Непрерывная интеграция (Continuous Integration, CI) и непрерывная поставка (Continuous Delivery, CD) представляют собой культуру, набор принципов и практик, которые позволяют разработчикам чаще и надежнее развертывать изменения программного обеспечения.     

Непрерывная интеграция — это методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами. И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений.      

![alt text](./img/ci_cd.png)

А тут что-нибудь покажу с CI в GitLab, мб докерами на лекции..