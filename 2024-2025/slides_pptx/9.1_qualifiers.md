## Квалификаторы.  

Квалификаторы применяются при объявлении переменных и их всего несколько штук в языке Си: const, volatile, restrict.   

### const

Константная переменная.  
Если объявили переменную единожды и что-то в нее записали, то эту переменную больше не изменить.   
```c
const int a = 123; // или int const a;  
a = 555; // Ошибка  
```
Хотя переменная a и является константой, все же изменить ее возможно если взять ее адрес с помощью указателя на int (не const int) и что-то поменять разименовав этот указатель.   

Указатель на константу.  
```c
const int a;
const int *p = &a;  
p = (int *)5; // Ок, меняем адрес p, а не значение константы a  
*p = 321; // Ошибка, пытаемся поменять константное значение.  
```

Константный указатель.
```c
int a;
int *const p = &a;
p = (int *)5; // Ошибка, т.к. у нас указатель константный и не может менять свое значение.
*p = 321; // Ок, т.к. у нас переменная не константа
```

Константный указатель на константу.
```c
const int a;
const int *const p = &a;
p = (int *)5; // Ошибка, т.к. у нас указатель константный и не может менять свое значение.
*p = 321; // Ошибка, т.к. у нас переменная является константой
```

Зачем константы и константые указатели? По сути это все нужно для того чтобы кто-то случайно не смог изменить значение переменной, т.к. случайно или намеренно ее изменив можно получить кучу различных ошибок при выполнении кода (Runtime).    
Указатель на константу зачем? Пример: в функцию передаем некоторую строку и мы не хотим чтобы ее кто-либо в функции изменил, поэтому передаем и принимаем в самой функции в качестве аргумента указатель на константу.      

### extern

extern - используется для использования глобальной переменной, объявленной в одном .c файле в других .c файлах. Пример:   
file1.c   
```c
int a;
char b;
int main(void) {
  ...
}
```

file2.c   
```c
extern int a;
extern char b;

void func() {
  a = 5;
  b = 'A';
}
```

В данном примере в file1.c объявлены две глобальные переменные int a и char b. Для того чтобы увидеть их в file2.c и использовать, мы должны в file2.c объявить эти же переменные с таким же именем и типом данных, но с ключевым словом extern.    


### static

static - применяется для функций и переменных. Это некоторая глобализация переменных в районе одного файла.   
Пример:
```c
static int func(void) {
  static int a = 0; // инициализирует единожды глобально
  a++;
  return a;
}

int main(void) {
  printf("a = %d\n", func());
  printf("a = %d\n", func());
  printf("a = %d\n", func());
}
```
Если убрать слово static перед переменной a, то a будет всегда равна 0 в printf() из main(), однако если будет слово static, то наша переменная станет глобальной и вывдется на экран a = 0, a = 1 и a = 2.    
Если слово static есть при функции, то данную функцию невозможно вызвать в других .c файлах. Тоесть эта функция доступна для вызова из данного .c файла. Это что-то вроде некоторой защиты переменных модуля от изменения из других модулей проекта. Например, мы не хотим чтобы пользователь вызывал некоторые из наших функций из нашей библиотеки и как-то что-то нам ломал, мы делаем эти функции статичными, т.е. вызвать их не получиться из других модулей.         


### restrict 

Используется для оптимизации. Чаще всего примяняется для указателей и чаще для указателей на char (строки).   
Пример если у нас есть функция с двумя массивами, которые в памяти никак не пересекаются (друг на друга не накладываются), т.е. оба указателя указывают на разные массивы, то компилятор такой код слегка оптимизирует.      
restrict указывается программистом компилятору, что эти два массива у нас никак не пересекаются в памяти и можно применять некоторую оптимизацию в ассемблере для ускорения кода.   
Маленький пример на Си, который можно посмотреть в ассемблере со словом restrict и без него и сравнить кол-во строк ассемблера функции add:         
```c
void add(int *restrict p1, int *restrict p2, int *restrict val) {
  *p1 += *val;
  *p2 += *val;
}
int main(void) {
  int a = 1, b = 2, c = 3;
  add(&a, &b, &c);

  return 0;
}
```
Компилировать с оптимизациями и также утилита objdump и флаг -d в помощь.    

Ассемблер функции add без restrict:   
```c
0000000000001140 <add>:
    1140:       f3 0f 1e fa             endbr64 
    1144:       8b 02                   mov    (%rdx),%eax
    1146:       01 07                   add    %eax,(%rdi)
    1148:       8b 02                   mov    (%rdx),%eax
    114a:       01 06                   add    %eax,(%rsi)
    114c:       c3                      ret    
```
Ассемблер функции add с restrict:   
```c
0000000000001140 <add>:
    1140:       f3 0f 1e fa             endbr64 
    1144:       8b 02                   mov    (%rdx),%eax
    1146:       01 07                   add    %eax,(%rdi)
    1148:       01 06                   add    %eax,(%rsi)
    114a:       c3                      ret    
```
С restrict компилятор уберет одно лишнее копирование. В этом притянутом за уши примере изменилась лишь одна строка, но это очень здорово когда у нас подобная функция вызывается очень-очень часто в программе и такая оптимизация чуть ускорит работу нашей программы.   
Без restrict компилятор побоиться такое оптимзировать.    
restict в данном примере нужен лишь для int *restrict val, но если указываем для одной переменной, то обычно и для всех остальных тоже указывают, чтобы читалось как все эти аргументы не пересекаются в памяти между собой.   

Также пример стандартных функций - это memcpy() и memmove() из <string.h>.    
```c
#include <string.h>

void *memcpy(void * restrict s1,  /* копируемые области не должны пересекаться */
    const void * restrict s2, size_t n);

void *memmove(void *s1,  /* копируемые области могут пересекаться */
  const void *s2, size_t n);
```

### volatile

Ключевое слово volatile указывает на то, что объявленная таким образом переменная может измениться независимо от действий программы. Смысл использования квалификатора заключается в том, что компиляторы могут оптимизировать код, использующий переменную без учёта возможности её изменения в силу внешних условий.   
Простыми словами мы говорим компилятору не оптимизируй переменную с таким квалификатором, т.к. она может изменить неочевидным способом для компилятора, например через указатели.   
```c
int main(void) {
  int a = 5;
  if (a == 5) {
    printf("a = 5\n");
  } else {
    printf("a != 5\n");
  }
```
В данном примере a = 5 и компилятор при оптимизации удалит все if else и оставит лишь printf("a = 5\n");. Но со словом volatile компилятор не станет оптимизировать это условие.    

### auto

[Ответ про auto взят отсюда](https://tproger.ru/articles/article-auto-c)
auto – это старое ключевое слово C, обозначающее “локальную область видимости”. auto a эквивалентно int a. Еще пример такого это   
В C++ это слово вернули, но уже с новым смыслом (теперь эта конструкция позволяет явно не указывать тип переменной).

### register
Доступ к регистрам осуществляется быстрее, чем к оперативной памяти, поэтому переменные, которые наиболее часто используются в программе на языке C, можно поместить в регистры с помощью ключевого слова Register.    
Ключевое слово Register указывает компилятору, что данную переменную можно поместить в регистр. Помещать его в регистр или нет — выбор компилятора. Обычно компиляторы сами выполняют оптимизацию и помещают переменные в регистр.   

[Пирамида иерархии памяти](https://ru.wikipedia.org/wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8):   
![image](https://github.com/user-attachments/assets/933821c7-8a6d-4d79-83a7-8447287a2227)   




  
