# Коротко о первом семестре   

### Анализ

В вводной лекции мы начали с знакомства с понятием языка программирования и небольшого сравнения ЯП с естественными языками. И пришли к таким непонятным словам в программировании: Синтаксис, семантика и лексика.   
* **Лексика (Lexicon)** - относится к набору допустимых символов и токенов в языке программирования. Отвечает на вопрос: Какие слова и символы можно использовать в предложении?..
  * Ключевые слова типа "for", "if", "else", "while"..
  * Идентификаторы - допустимые имена переменных.
  * Операторы - +, -, &&, |, ~ и т.д.
  * Разделители - символы, разделяющие токены, пример " ", ";" ","...
* **Семантика (Semantics)** - относится к значению и смыслу программных конструкций. Отвечает на вопрос: Является ли написанное предложение корректным? Если да, то что оно делает?..
  * Как интерпретировать выражения, пример "x++" - прибавить к значению "x" единицу и записать результат в "x"
* **Синтаксис (Syntax)** - относится к правилам и структуре языка программирования. Отвечает на вопрос: Как построить правильное предложение?..
  * Структура предложения: Как правильно написать цикл "while" или условие "if-else", куда ставить круглые скобки, а куда точку с запятой

У каждого ЯП свои свои собственные правила лексики, семантики и синтаксиса и программы, написанные на каком-то ЯП должны соответствовать правилам этого ЯП.   


### Классификация

Важный аспект программирования – классификация, программисты бывают очень разные и решают очень разные задачи, для решения задач как раз и создают языки и парадигмы, большинство парадигм, как и языков зародилось в 70-е годы и все это используется до сих пор.   
Важно понимать, что ЯП - это инструмент для решения задач. **Не существует универсальных Языков Программирования**. ЯП с его парадигмой следует выбирать исходя от задачи. Скажем на том же языке Си можно написать все и решить все известные задачи, но время (самая дорогая штука), которое потребуется потратить для решения некоторых задач будет неоправданно большим, в сравнении с тем, что если бы мы решали задачу на ЯП, предназначенном для этого типа задач.      

Языков программирования сейчас очень много, наверное уже около одной тысячи.   
Мы изучаем с вами один из самых простых ЯП для понимания Си. [C](https://www.youtube.com/watch?v=cdX8r3ZSzN4&ab_channel=kawaii_desu_integral) - отец многих современных языков программирования. Язык Программирования, что старше нас и всех нас переживет.    

С этим языком мы с вами пытаемся прокачать мозг в части основ программирования, т.к. все современные языки предлагают абстракции и готовые черные ящики для решения задач, но как эти вещи действительно работают? Как например транспонировать ту же матрицу своими ручками?)    

Если вы знаете C, то будет легче выучить многие из них (большинство крупных языков наследуют синтаксис Си в некотором роде) или хотя бы иметь некоторое понимание как они работают под капотом. Конечно выучить синтаксис любого языка можно за пару вечеров, но времени на понимание языка все равно уйдет много.         

Кроме того, Cи помогает нам понять, как работает наш компьютер и ОС. Этот язык очень близок к языками низкого уровня программирования, ниже лишь Ассемблер, изучение которого будет пыткой.   

Даже бетховен в свое время написал симфонию на Си (**Symphony in C**)     


### Трансляция

Программы написанные на ЯП должны быть транслированы (или **переведены**) в понятные процессору машинные слова (0 и 1). Мы пишем на языках высокого уровня, а не на машинном языке, поэтому нам нужно через переводчик перевести наши английские слова в машинные слова.
Переводчики чаще всего встречаются двух видов - **интерпретатор** и **компилятор**.    

![image](https://github.com/user-attachments/assets/0e09a525-43a1-48ce-8a6a-2b81917d3046)


### Архитектура

В любом пк, телефоне, умном чайнике и т.д. всегда будет эта пара: **Процессор** и **Оперативная память**, т.к. процессор читает инструкции написанных нами программ из оперативной памяти.   
В саму же оперативную память программы загружаются из ПЗУ - каких-то энергонезависимых хранилищ данных (это значит, что данные останутся даже если устройство выкл.), например жесткий диск, SSD, флешка, SD-карта и т.д.  

Архитектура – это некий набор свойств и качеств, которые присущи тому или иному семейству процессоров. Процессоры в телефонах имеют одну архитектуру, а в компьютерах другую.     
Хотя бы две можно держать в голове - **x86** и **arm**:
* CISC (англ. Complex Instruction Set Computer — «компьютер с полным набором команд») 
* * x86 (он же IA-32) и x86_64 (он же AMD64), процессоры в наших ПК
* RISC (англ. Reduced Instruction Set Computer — «компьютер с сокращённым набором команд»)  
* * Серия архитектур ARM (ARM7, ARM9, ARM11, Cortex), процессоры в наших телефонах и на Mac


### Компиляция. Hello, world!

Для запуска программ, написанных на языке Си нам понадобится компилятор - программа-переводчик языка Си в машинные инструкции, понятные процессору. У нас есть два популярных компилятора - **GCC** и **clang**.     

Переводим мы файлы с исходным кодом - файлы, написанные на языке программирования. Машинный код - файл, состоящий из машинных инструкций (0 и 1), то что понимает процессор. **Процессор не понимает английские слова, он понимает лишь машинные инструкции из 0 и 1.**    
   
![image](https://github.com/user-attachments/assets/c59fb5ee-39eb-40df-9b5b-23d4f0f22b60)   
![image](https://github.com/user-attachments/assets/b0f22369-3aba-43cc-8ff3-ba5f62bd3c21)   


Компиляция делится на 4 этапа и на каждом из этапов можно остановиться и посмотреть выходной файл. Идете на собес со знанием компилируемого языка - разузнайте этапы компиляции этого языка хотя бы в общих словах.    
     

![image](https://github.com/user-attachments/assets/14fc1dad-3d8d-48d5-9b62-dc9c6afb9f07)



### Переменные, константы и типы данных

Как и у всех высокоуровневых ЯП в СИ есть переменные, т.е. то куда мы кладем символы, числа, строки для хранения и дальнейших вычислений. Язык Си - статически типизированный, т.е. переменные должны объявляться с конкретными типами данных одиин раз и не меняться всю программу. Каждый из этих типов данных занимает в памяти определенное количество байт и отсюда фиксированные диапазоны значений. Например: char - всегда 1 байт на всех архитектурах. Все остальные типы данных могут иметь другие размеры в зависимости от архитектуры. Также типы данных могут по разному расположиться в памяти, пример - отрицательные и положительные целые числа, вещественные числа (IEEE-754).      

![image](https://github.com/user-attachments/assets/e5655bf8-abb5-4c0d-8b8a-07785c56724b)    

Один раз мы объявляем переменную указывая ее тип и имя:
типДанных имяПеременной;  
int a;  

А после объявления можно с ней что-либо делать:   
имяПеременной = константа; // либо присвоить значение другой переменной  
a = 5;  

В данном выражении "a = 5", a - переменная, 5 - константа. Константы бывают разные:     
![image](https://github.com/user-attachments/assets/d61dc24b-5e2c-4a92-91a8-b4d60e45f987)  

Над переменными мы можем совершать различные операции с помощью доступных нам операторов:     
![image](https://github.com/user-attachments/assets/be7df9db-4262-4ca6-b2c4-e288a2bc1047)    
![image](https://github.com/user-attachments/assets/f52534bc-0017-455c-8f83-0f905e067161)   

Также стоит не забывать, что операторы имеют свой порядок выполнения.    

### Условия, циклы

Условные конструкции собираются из оператора **if-else** или **switch-case**     
Циклы в Си бывают трех видов: **while**, **do..while** и **for**     

Только 0 есть ложь (false), все остальное это истина (true).

По синтаксису см. примеры из прошлых лекций и гита.      

Что в циклах, что в условиях можно создавать более сложные условия из условных операторов:     
![image](https://github.com/user-attachments/assets/05346545-ddd6-451b-ba25-5bbb918a2b89)
 

### Функции ч.1

Функция - блок кода, который может содержаться в основной программе, а может быть создан отдельно (в библиотеке). Каждая функция выполняет в программе определенные действия и несет цель обобщения, т.е. решение какой-то конкретной задачи.   

Определение функции (Мы определяем, что она делает):  
```c
типВозвращаемогоЗначения имяФункции(Аргументы) {
    // Тело функции
    return (Возвращаемое значение);
}
```

Объявление функции (Мы объявление, что она из себя представляет):   
```c
типВозвращаемогоЗначения имяФункции(Аргументы);
```
Еще называют заголовком функции или прототипом.  

Для перехода в функцию ее необходимо вызвать:   
```c
типВозвращаемогоЗначенияФункции имяПеременной = имяФункции(Аргументы);
```
где имяФункции(Аргументы) - есть вызов функции, т.е. мы прыгаем в саму функцию, выполняем ее код и возвращаемся назад.   

Функции нам нужны для того, чтобы мы реализовывали в самой функции решение какой-либо задачи, например найти определитель матрицы NxN или удалить из входной строки все пробелы, а затем для **ЛЮБЫХ** входных данных эта функция (блок кода) решала свою задачу. Т.е мы решение задачи упаковываем в отдельную функцию и когда нам потребуется для некоторых входных данных решить эту задачу мы вызовем эту функцию, передав все входные параметры.    

типВозвращаемогоЗначения у функций может быть любой из примитивных типов в Си - int, char, структуры данных, указатели и даже void, где последний означает, что функция ничего не возвращает (пустой return или вовсе его отсутствие). Функции в Си не умеют возвращать массивы.   

Функция main() - функция, с которой начинается любая программа на языке C/C++.   


### Битовые операции

Нужны нам для доступа к конкретным битам числа, часто используется в криптографии, в сетях и системном ПО. Битовые операции единственный способ доступа к битам числа (Вру, можно еще через структуры данных). Бывают следующие битовые операторы:   
![image](https://github.com/user-attachments/assets/19d50310-1aa0-4274-9b5c-5c9b647939ef)

При работе с битовыми операциями работает Булева алгебра.   

### Массивы

Когда мы хотим иметь в одной переменной сразу несколько значений **одного типа данных**, то мы обращаемся к такому явлению как массивы. Массивы складируют значения в памяти друг за другом.     
![image](https://github.com/user-attachments/assets/83b11163-bb95-4871-b8d2-c7446173c97c)


**В почти всех ЯП обращение к элементам массива начинается с 0.**   

Матрицы - они же двумерные массивы (массивы массивов), все те же самые массивы, но появляется новые квадратные скобки с еще одним индексом, где первые [] - номер строки, а вторые [] - номер столбца в матрице.    

Никто не заставляет ограничиваться лишь массивами в массивах, можно создавать 3-х, 4-х и более n-мерные массивы, однако следуюет помнить, что такие массивы данных будет дольше и сложнее обработать. Да и самим запутаться легко где какой индекс за что отвечает.     
![image](https://github.com/user-attachments/assets/35ca9b43-858e-4142-ae6e-8a3b3c48e0bc)


#### Строки

Строки в Си - это есть массив из символов (char). Т.е. это просто одномерный массив из char. Если создать двумерный массив из char - то такую штуку можно обозвать массивом строк.   

Все строки обычно заканчиваются на специальный символ - '\0', означающий конец строки. Его называют еще NUL-терминатор. Он необходим для различения строк в памяти (как printf при выводе на экран понимает когда закончилась строка?)             
![image](https://github.com/user-attachments/assets/f9b99f1d-a0e3-474c-ba4c-85e190cde51a)


Для обработки строк в Си есть некоторые функции из стандартной библиотеки Си, заголовочный файл - <string.h>. Однако если перед вами будет стоять задача парсить большие объемы текста и строк, то лучше подумать о других ЯП, прекрасно решающих подобного рода задачи.       

### Указатели   
Виды адресаций:   
![image](https://github.com/user-attachments/assets/54cffab0-5579-4193-88f4-5a8b266dc3e8)   

**Указатели** - на самом деле это лишь переменная, хранящая в себе адрес. Под адресом мы подразумеваем смещение от 0 в оперативной памяти до нашей переменной, т.е. если переменная char a находится по адресу 100, то это значит, что a будет располагаться начиная с 100 байта и занимать 1 байт.    

Размер указателя зависит от разрядности системы, если у нас 32-битная система - то размер указателя 32 бита, т.е. 4 байта, если что-то более современное - 64 битная система, размер 8 байт. Т.е. теоретически указатель может адрессовать в памяти значения от 0 до 2^64-1 байт.    

Указатели обычно указывают на какой-либо тип данных, например на int. Это необходимо для того, чтобы знать сколько байт необходимо прочитать/записать после перехода по адресу, лежащему в указателе. Сам переход по адресу из указателя и чтение/запись называется **разименованием**. 

Для взятия адреса переменной используется "&":
```c
char a = 'A';
char *p = &a; // адрес a запишется в переменную p.
```    

![image](https://github.com/user-attachments/assets/c29c0fe7-b0b9-4f87-bf33-da6e764a2533)


У указателей есть свой 0: "NULL". При попытке разименовать NULL вы гарантировано получите segmentation fault.   
Отсюда следует, что лучше всегда локальные переменные инициализировать NULL, чтобы через отладчик в случае чего было легко найти и исправить ошибки с указателями.    

У указателей существует своя математика:
```c
int *p = 100; 
p++; // p = p + 1;
printf("%p", p); // <= 104
```
При добавлении 1 к указателю добавляет не 1 байт, а 1 * sizeof(на что указываем) байт, т.е. sizeof(int) == 4.      
![image](https://github.com/user-attachments/assets/ddddc065-d255-4c92-9770-3140b86b450e)


Указатели могут указывать на другие указатели.     
![image](https://github.com/user-attachments/assets/844cb4bb-f157-4136-b65c-ba3d343870c7)


### Динамическая память

Выделяется память в области именуемой "heap" (куча). Для работы с такой памятью используются указатели и функции malloc(), calloc(), realloc(), free(). Контролирует такую память сам разработчик, в Си нету сборщика мусора и в случае некорректной работы с дин. памятью могут возникать утечки памяти, которые кладут программу (в худшем случае систему).    

Вся ответственность по управлению памятью лежит на разработчике. И это не язык виноват в ошибках, а сам разработчик. Отсюда и скорость работы программ написанных на Си.      

#### Модель памяти

Модель памяти у языков программирования разная, но что-то будет похоже, у языка Си примерно следующая:      
![image](https://github.com/user-attachments/assets/a49d73f5-2a10-440c-a8bd-0455fcade142)


#### Стек и куча
Стек и куча - две области памяти, с которыми постоянно будем работать.
Стек - это все переменные в функциях, куча - память выделенная через malloc, calloc, realloc.         
![image](https://github.com/user-attachments/assets/739ebe20-7d05-42c6-822e-78609e0b9827)


### Функции ч.2

Оказывается:
* Существует рекурсия - функция, что вызывает саму себя.   
* Функции имеют адреса - существуют указатели на функцию
* Callback
* Dangling ptr (Висячий указатель)
* Функция main умеет принимать аргументы из командной строки
* Variadic функции

API функций - одно из важнейших понятий, касаемых функций в программировании.     
API (Application Programming Interface) – программный интерфейс приложения, описывает протокол взаимодействия между программами. Представляет собой набор классов, функций, структур или констант.      

![image](https://github.com/user-attachments/assets/983bd3b7-7ca4-4859-8f3a-f17483e06c23)


### Препроцессор

Все, что начинается с решетки "#" - препроцессорная директива, это такие штуки, которые обрабатываются на первом этапе компиляции (**не в Runtime!**). Пример #include, #define.     

### Структуры данных

Структура — если коротко, то это штука, подобна массиву, однако позволяет содержать в себе данные разных типов.

в общем виде синтаксис структуры следующий:
```c
struct ИмяСтруктуры
{
тип ИмяЭлемента1;
тип ИмяЭлемента2;
...
тип ИмяЭлементаn;
};
```
и пример структура кота:
```c
struct Cat { // определение структуры  
  char *name; // имя кошака  
  unsigned int age; // возраст кота  
  char *color; // цвет  
}; // конец определения  
```

Без указателей здесь тоже никуда. Если у нас переменная-указатель на структуру, то для получения элемента стрктуру используется '->', если у нас просто переменная структура - обращаемся через '.'.  

Бывают еще union, enum и typedef.   


### Отладчик

Незаменимый инструмент при разработке больших программ. Позволяет остановить выполнение программы (с помощью breakpoint - точки останова) и посмотреть в каком она состоянии находится - вывести значения переменных в определенной функции определенного процесса/потока (стек вызова функций).

### Valgrind и ASan

Инструменты по отладке проблем, связанных с памятью, например переполнения стека/кучи, утечки памяти и т.д. В реальных проектах самому будет почти нереально уследить за всеми malloc и free, поэтому предпочтительнее и проще обнаружить проблемы будет, используя специальные для этого инструменты.

### Многофайловые проекты. Системы сборки Make, CMake

Реальные проекты довольно объемные и складывать все в одном файле нецелесообразно по многим причинам.

Make, CMake - инструменты для сборки больших проектов, позволяют разработчикам собирать любой сложности проекты парой простых команд.      

### Github

Система контроля версий. Используется разработчикам для хранения и управления версиями исхного кода при разработке всего.    
Познакомимся поближе с ним в следующем семестре.    
