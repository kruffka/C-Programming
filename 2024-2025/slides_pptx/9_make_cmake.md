В этом файле рассмотрим что такое многофайловые проекты, зачем они нужны, а также системы сборки.  

## Многофайловые проекты.  

Почему не пишут проекты в одном файле, зачем разбивают на файлы если можно все написать в одном файле и оно заработает.   
Конечно так можно сделать и оно действительно заработает, однако чем больше будет такой проект тем менее читабельнее он как и для самого разработчика так и для тех людей, которым он достанется в наследство для дальнейшей разработки.  
Реальные проекты часто состоят из нескольких тысяч, а иногда даже и нескольких миллионов строк кода. Например взять то же ядро Linux и попробовать посчитать кол-во строк кода и можно приятно удивиться цифрам: [wiki кол-во строк кода в Linux ядре](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D1%81%D1%82%D1%80%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%B0#%D0%9F%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82_%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%B0)    
Итого 18кк (18 373 471) строк кода содерижтся в проекте Linux 2017 года. Если данный проект переложить в один файл и пытаться его открыть прочитать, то даже ваш пк может сойти с ума.  

**Таким образом**, при разработке достаточно больших программ бывает удобным разрабатывать программу не в виде одного файла, а в виде нескольких. В отдельном файле сохраняем функцию main(), подпрограммы — каждую в отдельном файле или группируем по назначению.
Что это даёт? 
* Если у нас есть файл с функциями, решающий определенные задачи и мы захотим его перенести в другой проект, то без труда обычным копированием это сделаем. А если говорить о проекте с одним файлом, то здесь придется помучиться.
* Если над проектом работает больше одного программиста, то в проекте с одним файлом у вас будут вечно возникать конфликты с версиями кода.  
* При изменении файла в многофайловом проекте сборка проекта будет быстрее, т.к. нужно пересобрать лишь конкретный файл.  

**Итого**: многофайловый проект - есть способ разбить программу на отдельные модули, каждый из которых имеет собственный функционал и они не зависимы друг от друга. Также ткие модули можно использовать в других проектах.

Многофайловый проект в C состоит из файлов с расширениями .c и .h. В C++ расширения .cpp (либо сейчас модно .cc) и .h (или .hpp).  
Файлы с расширением '.c' (либо .cc или .cpp) - содержат исходный код программы с функциями, решающие конкретные задачи.  
Файлы с расширение '.h' (или .hpp) - называются заголовочные файлы (от англ. Header) т.к. в таких файлах содержатся заголовки функций (прототипы). И такие .h файлы обычно включаются в файлы .c директивой #include.   

Один из способов разбиения файлов в многофайловом можно представить примерно так в виде дерева:  
```
-my_project          // Мой проект
  |-app              // Само приложение, здесь все начинается и находится main()
  |-task1            // Код программы, решающий проблемы задачи 1  
  |  |-src           // Здесь исходники    
  |     |- *.c       // Файлы с функциями    
  |  |-include       // Здесь заголовки     
  |     |- *.h       // Заголовочные файлы    
  |-task2            // Код программы, решающий проблемы задачи 2
  |   |- task2.1     // подзадачи
  |   |   |- *.c *.h // и исходники и заголовочные файлы    
  |   |- task2.2     // подзадачи  
  |-common           // Какие-то общие вещи для всех   
  |-third-party      // Сторонние проекты   
  |-docs             // Какая-то документация
  |-tests            // или examples: Какие-то тесты и примеры с функциями из task1, task2  
  |-README.md        // Краткая подсказка по вашему проекту, например: что за проект и как собрать   
```

В данном примере у нас есть проект с названием my_project, содержащий каталоги task1, task2, в которых код разбит еще на каталоги. Так можно разбивать очень долго, но всегда нужно это делать в меру и не заниматься маразмом.   
Выделить крупные задачи несложно, скажем пишем мы мобильное приложение для работы с банком, можно попробовать разбить это на более крупные проблемы, которые в свою очередь поделить на более мелкие:  
* Авторизация (Логин пароль при входе)
* Интерфейс взаимодействия с пользователем (User Interface)
  * Кнопка отправить деняк другу
    * Исходники кнопки
  * Получить информацию о том сколько деняков на счету
  * Кнопка считать QR-code
  * ...
* Реализация кнопки чтения QR-code (работа с камерой телефона)
* Интерфейс с сервером банка
  * Отправить запрос
  * Получить ответ
* ...
  
Говоря про разбиение на файлы мы немного затрагиваем архитектуру приложений, а это очень большая и непростая тема, которую нужно осваивать самостоятельно. Например "Современный подход к архитектуре ПО" (в эиосе есть архив, где лежит эта книга).   


## Сборка многофайловых проектов

При написании таких проектов можно столкнуться с проблемой повторного включения заголовочных файлов, ее решение дано на слайдах лекции про препроцессор и директивы. (#ifndef #define #endif)     

Для сборки файлов достаточно в компилятор передать файлы через пробел, например если мы находимся в папке app с main.c и собираем func.c из src:    
```bash
gcc main.c ../src/func.c -I ../include
```

Так мы получим один исполняемый файл, собранный из двух исходных файлов.   
Опция -I говорит о том, что мы хотим подключить заголовочный файл из include папки и при этом в .c файлах не прописывать полный путь в #include "имя файла"    

Если мы вспомним этапы компиляции и объектные файлы, то можно собрать проект немножко иначе.   
Объектный файл (расширение .o) - это файл, содержащий в себе машинный код, получается на 3 этапе компиляции GCC. Такой файл хоть и содержит код, который уже понимает процессор, но файл все еще не связан с функциями других библиотек (например printf) и в файле не говорится как ОС его запустить.  
Получить объектный файл можно опцией -c:   
```bash
gcc -c main.c  
gcc -c func1.c  
gcc -c func2.c  
```
На выходе получим эти самые объектные файлы наших исходников main.o, func1.o и func2.o     
Теперь их можно связать и получить бинарник,        
```bash
gcc main.o func1.o func2.o    
```
который уже можно запускать.   
В чем смысл такой компиляции? Смысл следующий: если мы поменяем что-либо в коде файла func2.c, то нет необходимости пересобирать все наши файлы, т.е. время сборки немного сократиться за счет того, что пересобирать нам нужно лишь func2.c и затем связать с объектными файлами main.o и func1.o.  
В действительно больших программах это очень существенно, вам при каждом малейшем изменении программы не нужно ждать пару часов пока весь проект соберется, вместо этих часов он соберется за секунды, т.к нужно скомпилировать один отдельный файлик.     

С многофайловыми проектами более менее разобрались, а что если мне другой разработчик дает проект с кучей разных файлов, которые я вижу в первый раз, мне же придется искать все *.c и *.h файлы и разбираться где какие зависимости у файлов и функци. Как-то сложно..   
Но для таких ситуаций у нас есть такие штуки как системы сборки.   
  
**Системы сборки кода** — это специальные программы, которые собирают и пересобирают код проекта в автоматическом режиме по заранее заданным правилам.    
Эти системы определяют зависимости между файлами с исходным кодом и выходными файлами (программами, библиотеками и конфигурационными файлами) и в нескольких параллельных процессах выполняют команды компиляции для всех изменившихся со времени последней сборки файлов, соблюдая зависимости.    
Вторая задача систем сборок — это поиск в операционной системе и подключение к проекту библиотек и программ, которая реализуется наиболее удобными способами в зависимости от операционной системы.    
Рассмотрим самые популярные.   

## Make  




## CMake  


## Meson?  



## Квалификаторы

TODO ..
