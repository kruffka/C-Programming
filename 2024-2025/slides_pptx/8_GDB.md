## Отладчик
  
Отладчик - (англ. debugger от bug, баг) — компьютерная программа для отладки: поиска ошибок в программах.  
В зависимости от встроенных возможностей, отладчик позволяет выполнять трассировку, отслеживать, устанавливать или изменять значения переменных в процессе выполнения кода,  
устанавливать и удалять точки останова или условия остановки, выводить стек и кадры функций, перемещаться между потоками в многопоточной программе и т.д.  
  
С каждой новой строчкой кода в проекте растет вероятность ошибок, которые в нем могут возникнуть и для нас как для разработчиков отладчик является очень мощным и неотъемлимым инструментом при написании и отладки кода.     
  
Немного истории: понятие баг в айти зародилось еще в прошлом веке и под словом баг понимают какие-то ошибки в коде, препятствующие нормальной (правильной) работе программы. Хотя bug в переводе с английского означает «жук».  
Оно пришло в программирование из сленга инженеров, которые так называли ошибки при работе электронных схем.  
А в 1947 году создательница первого компилятора Грейс Хоппер обнаружила в компьютере Mark II мотылька, закоротившего контакты.  
В журнале происшествий написали: «First actual case of bug being found.». [wiki bug (engineering)](https://en.wikipedia.org/wiki/Bug_(engineering))  
С тех пор ошибки в программах продолжают обзывать багами.  

В нашем курсе мы будем пользоваться отладчиком GDB, который используется для отладки программ на C/C++.
Для его установки на Linux нужен интернет и команда: 
```
sudo apt install gdb -y
```


## Компиляция программы для отладки

Допустим у нас есть [исходный код](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex1.c) и мы хотим его поотлаживать в отладчике.  
Для этого попробуем скомпилировать программу:  
```gcc ex1.c```  
Получим исполняемый файл a.out и подсунем его в gdb, написав имя отладчика и через пробел имя исполняемого файла:  
```gdb ./a.out```  
При запуске увидим что-то похожее на:  
![image](https://github.com/user-attachments/assets/574a2641-2ac8-49df-9880-8c9866e4f838)

Много текста, но самое важное здесь это последние несколько строк:
![image](https://github.com/user-attachments/assets/16eddb09-f4c2-4a5f-aa26-890f7f5d00ec)

Строка "Reading symbols from ..." означает, что отладчик пытается прочитать отладочные символы из исполняемого файла a.out, а ниже в скобках сообщает о том, что этих символов не найдено в a.out.  
Отладочные символы (debug symbols) - это дополнительная информация, связанная с исполняемым кодом, которая используется для диагностики и отладки программного обеспечения. Например это имена функций, имена переменных, номер строки кода и т.д.   
Эти отладочные символы в исполняемый файл записывает компилятор. Для их появления используются специальные флаги (опции) при компиляции программы:

| Опция | Описание |
|------|---|
| -g  | Добавляет в выходной файл отладочную информацию  |
| -g0 | без отладочной информации |
| -g1 | минимальный уровень информации, достаточно для просмотра backtrace  |
| -g2 | уровень отладки по умолчанию (то же самое, что и -g)  |
| -g3 | включение доп. отладочной информации, например для раскрытия макросов  |

Помимо отладочной информации необходимо добавлять опции оптимизации программы компилятором  

| Опция | Описание |
|------|---|
| -O0  | Без оптимизаций |
| -O1, -O2, -O3 | Различные уровни оптимизации |
| -Os | Оптимизация по размеру программы |
| -Ofast | Все оптимизации уровня -O3, плюс дополнительные  |

Компилятор очень сложная и хитрая штука, он может до не узнаваемости оптимизировать наш код, так что он будет не соответствовать тому, что мы написали, 
однако при запуске программы мы все равно получим то, что ожидали.  

Итак скомпилируем программу без оптимизаций (-O0) и с добавлением отладочной информации (-g):
```gcc ex1.c -g -O0 -o ex1```  
Получим исполняемый файл ex1, если сравнить размер с предыдущим исполняемым файлом a.out, то увидим что компилятор чего-то добавил нового в ex1:

```ls -lh```  
![image](https://github.com/user-attachments/assets/cceb8e6b-adce-49cf-845e-24208655ca80)    
Этот 1 кбайт информации и есть отладочная информация. Теперь запустим новый исполняемый файл в отладчике:  
```gdb ./ex1```  
![image](https://github.com/user-attachments/assets/1cfadc4d-220f-4759-869a-339acf7757da)    
Видим, что отладчик прочитал символы и больше не жалуются об их отсутствии. Теперь можно приступать к отладке программы.  


## Консольный GDB

Немного новых понятий:
Для остановки выполнения программы используются точки останова (breakpoints). 
Если наша программа имеет аргументы в функции main(), то для запуска необходимо прописать опцию для gdb --args:
``` gdb --args ./a.out arg1 arg2```
Командная строка в gdb начинается с текста ```(gdb)```. Туда мы будем вводить команды.

Команды:  
break - поставить точку останова (breakpoint)   
info - информация о чем-либо  
delete - удалить что-либи (например breakpoint)  
run - запуск программы   
exit - выйти из отладчика (еще можно quit либо сочетание клавиш CTRL+D)  
next - сделать шаг (перепрыгивает вызовы функций)  
step - сделать шаг (запрыгивает в функции)  
continue - продолжить выполнение  
list - просмотр исходного кода +/- 5 строк   
disassemble - просмотр ассемблер кода  
print - просмотр текущего значения переменной  
display - просмотр значения переменной каждый шаг  
examine - рассмотреть байты начиная с адреса  
backtrace - вывести стек функций с номерами кадров    
frame - выбрать кадр функции (после frame указывается номер кадра)  
macro expand - раскрыть макро-определение (только при -g3)   
help - Список некоторых команд gdb  

Каждую из комманд приведенных выше необязательно полностью печатать, например вместо "run" можно писать "r", вместо
"break" можно "br" и т.д.
При выходе из gdb все точки остановы удаляются.  

### Пример 1
Продолжим отлаживать [пример ex1.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex1.c):     
Попробуем поставить точки останова (breakpoints) на функции main() ```break main``` и в строке 5 ```br 5```:  
![image](https://github.com/user-attachments/assets/ff9f5201-b4d5-4565-8926-db25ca6e5eeb)   
Увидим фидбек от компилятора, что он поставил эти точки в нужых местах. Теперь попробуем запустить программу командой ```run```:  
![image](https://github.com/user-attachments/assets/e12c232a-5d95-4c6c-b125-2163be88b3a7)   
Увидим какие-то движения в сторону запуска программы и остановку программы на 1 breakpoint на первой строке кода функции main() в 8 строке программы.  
Попробуем вывести исходный код в отладчике командой ```list```:   
![image](https://github.com/user-attachments/assets/7c6b4e73-9185-4f05-bbc8-b038620cbe37)   
Увидим исходный код нашей программы в отладчике. Если программа будет больше и мы продолжим вводить list, то будем видеть все последующие строки нашего исходного кода.
Можно ввести list *номер строки* чтобы увидеть +/- 5 строк кода от *номера строки*.    
Можно побаловаться поглядев на какой инструкции ассемблера наша программа остановилась командой ```disassemble```:     
![image](https://github.com/user-attachments/assets/f8c555ef-d07c-4033-b8ec-0317be9a35b6)   

Рассмотрим следующие полезные команды, это next. Команда next выполняет текущую строку и останавливается на следующей.
Введем ```next``` или сокращенно ```n```:   
![image](https://github.com/user-attachments/assets/5206f2e1-72b9-4993-8b44-a1906e5a6b4a)     
Выполнив команду next, мы положили в k значение 5 и перешли на строку с l = f(k);

Команда ```print``` или сокращенно ```p``` позволит вывести текущее значение переменной k:  
![image](https://github.com/user-attachments/assets/fde4fcd1-181e-4316-85d1-6464ce1c6663)   

Мы остановились на строке с вызовом функции f() и если вызвать ```next```, то мы просто перешагнем вызов функции и попадем на строку с printf(), а команда ```step``` позволить заглянуть внутрь функции. В этом все отличие step от next.    
Попробуем в эту функцию перейти, для этого напишем команду ```step```:   
![image](https://github.com/user-attachments/assets/44eb0fdf-64b8-4924-84d9-2e5437413d96)   
Итак, мы попали в функцию f() из функции main и даже сразу видим какое значение принимает аргумент x. Получается мы вызвали функцию f() из main() и эта функция в стеке создала кадр функции f(). Попробуем это вывести на экран командой ```backtrace``` или сокращенно ```bt```:    
![image](https://github.com/user-attachments/assets/efdaf4ad-bfe4-445b-a1e1-161343d0f312)  
Мы увидим стек вызовов всех функций, где под 0 кадром функции будет наша функция f(), а main будет под номером 1. Если функция f() вызвала свою функцию скажем b(), то main стал бы под номером 2, f() под номером 1, а b() номер 0.  
Командой ```info frame``` можно увидеть всю информацию о кадре функции f(), например какие аргументы и чему они равны, а также адреса возврата в функцию main(). Команда ```frame 1``` переключит нас на кадр функции 1 и мы сможем посмотреть переменные функции main.     
![image](https://github.com/user-attachments/assets/6a6dbe5d-e050-418d-9c1d-48aecda10670)  
Командой ```info``` также можно выводить информацию обо всех точках останова: ```i br``` (сокращение от info break):   
![image](https://github.com/user-attachments/assets/e5acf5f0-a117-4a25-b122-8010dcea623f)  
И как мы помним мы оставляли в 5 строке точку останова, попробуем до нее добраться пропустив 4 строку введя команду ```continue``` или сокращенно ```c```:   
![image](https://github.com/user-attachments/assets/eec48d72-d4b8-4cfb-ace4-217003087818)   
Команда ```continue``` продолжает выполнение программы до тех пор, пока мы не дойдем до конца программы или не наткнемся на точку останова.  
Попробуем перезапустить нашу программу написав снова команду ```run``` и подтвердив клавишей 'y':  
![image](https://github.com/user-attachments/assets/80d5308a-4974-41e0-8aa3-8a0f69c33496)  
Выведем всю информацию о точках остановы и удалим 2 точку остановы в 5 строке командами ```info br```, ```del br 2``` (или ```delete 2```):   
![image](https://github.com/user-attachments/assets/e5244fd3-70c3-470c-a980-6099805bb691)  
Поставим breakpoint с условием в 10 строке на то, чтобы отладчик остановился если l будет = 10 и запустим программу:  
![image](https://github.com/user-attachments/assets/8773d1ca-48c4-4bff-8ca7-ca3241a6b889)  
Очевидно, что l не равна 10, поэтому мы там не остановимся, а программа просто отработает до конца и завершится. Поставим точку останова в 5 строке и присвоим y значение 10:  
![image](https://github.com/user-attachments/assets/d1aa6905-53d2-4c66-9879-7c15e1291b2a)  
В данном примере мы поставили точку остановы в строке 5, поменяли во время выполнения программы значение y переменной на 10 командой ```p y=10``` и продолжили выполнение командой ```c``` (continue) после чего остановились на breakpoint с условием l == 10.  
Тоесть получается, что команда ```print``` помимо вывода значений переменных может их при выполнении программы менять на ходу на любое интересующее нас значение.  
Также, на самом деле, ```print``` умеет выводить в различных форматах числа:  
![image](https://github.com/user-attachments/assets/f75c0337-a3be-40c2-8174-2d93df9c7565)  
Где через / после команды прописывается формат: x - hex, o - octal, t - binary, d - decimal (по умолчанию десятичный)  

Для многофайловых программ после самих команд указывается имя файла, пример: ```break func.c:f``` или ```br user.c:59```.   

### Пример 2

[Пример 2: ex2.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex2.c)  
Попробуем отладить еще пару программ, используя отладчик GDB.  
Соберем программу и попробуем запустить ее без отладки:  
![image](https://github.com/user-attachments/assets/a1820867-1ffb-4c40-8617-f96d94f0c877)    
Увидим что-то непонятное и страшное, хотя на первый взгляд программа совсем обычная.  
Попробуем разобраться, возьмем и соберем с флагами для отладки: ```gcc ex2.c -g -O0```.   
Запустим в отладчике без всяких точек останова командой ```run```:    
![image](https://github.com/user-attachments/assets/15bc3e74-f965-4371-b32d-f886dd83265b)    
Сразу же увидим, что отладчик остановился на строке 8 и говорит, что там какая-то ошибка связанная с какими-то "автобусами".   
Вспоминаем команды отладчика и выводим переменную i на экран:   
![image](https://github.com/user-attachments/assets/6fc27589-ad40-4a55-9f8b-71aa2b81223d)    
Видим в переменной i значение 4294967295 и оно может показаться очень большим и похожим на переполнение переменной.  
Проделав всего два шага я уже вижу в каком месте ошибка и почему. Осталось понять как i становится такой. Поставим точку останова на начале цикла в строке 7. Перезапустим программу и выведем через команду ```display``` значение переменной i:   
![image](https://github.com/user-attachments/assets/f9db1eb2-c419-4ab9-b8e3-fc804e2129bd)  
Остановившись на цикле мы видим, что i еще равна какому-то мусору. Сделаем шаг, а затем еще и еще... на каждом шаге будем видеть как меняется значение переменной i:  
![image](https://github.com/user-attachments/assets/15c1fcfd-0a7d-418b-95a5-7a100c1968fc)  
Проходя шаг за шагом и приближаясь к 0 становится более очевидным момент с переполнением i:  
![image](https://github.com/user-attachments/assets/3bdd7c95-7c83-4440-994a-d4ba226a9800)  
В нашем цикле выполняется лишняя операция из-за условия выхода из цикла i >= 0, при i = 0 мы еще раз выполним цикл, но уже для i = -1, но т.к. i у нас еще и unsigned, то это будет 4 с хвостиком миллиарда, а не -1, что гарантировано приводит к ошибке.  

Немного про ошибку SIGBUS и Segmentation fault.  
SIGBUS - похож на segfault, тоже кладет вашу программу намертво, но отличие будет в том, что sigbus ошибка возникает, когда мы пытаемся залезть в память не валидную, т.е. туда куда физически нельзя. А segfault тоже ошибка с вылазеньем за память, но означает, что
мы залезли в валидную физическую память, но эта память не предназначена для нашей программы (это память другой программы).  


### Пример 3

[Пример 3: ex3.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex3.c)   
Предполагается, что функция swap должна произвести обмен значениями переменных a и b. Скомпилировав и запустив программу, легко убедиться, что этого не происходит.  

Попробуем запуститься в отладчике и посмотреть что не так. Установим точку останова в 11 строке и выведем значения и адреса переменных a и b:   
![image](https://github.com/user-attachments/assets/63cc5057-8496-4adf-9442-6f88a0792951)   

Прыгнем внутрь функции swap() и выведем адреса переменных a, b и их значения в конце функции:  
![image](https://github.com/user-attachments/assets/c46cf2bf-c7d2-4c63-aca6-ea3498862b34)  
Значения a и b поменялись, однако если присмотреться то адреса a и b будут отличаться от адресов a и b из функции main.  Почему так, да потому что вспоминаем теорию и функции..   
Для того чтобы поменять что-либо внутри функции необходимо это что-либо передать по адресу!  

<details><summary>Правильный вариант выглядел бы так:</summary> 
  
```c
#include <stdio.h>  
void swap(int *a, int *b) {      
    int tmp = *a;      
    *a = *b;      
    *b = tmp;  
}  
int main() {      
    int a = 0;      
    int b = 1;  
    printf("a = %d, b = %d\n", a, b);      
    swap(&a, &b);  
    printf("a = %d, b = %d\n", a, b);      
    return 0;  
}  
```

</details>


### Пример 4

[Пример 4: ex4.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex4.c)   
Отладчик может быть полезен в изучении поведения сложных макросов. Для этого необходимо скомпилировать программу с опцией –g3 и воспользоваться командой отладчика macro expand.  
(gdb) break main    
Breakpoint 1 at 0x400523   
(gdb) run   
Breakpoint 1, main () at csc_trace.c:16    
16          f();    
(gdb) macro expand CSC_TRACE("Hello")    
expands to: printf("%s: ""Hello",__FILE__":""__LINE__")    


### Пример 5

[Пример 5: ex5.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/8_gdb/ex5.c)   
Ожидается, что будет выведена строка, символы в которой отсортированы. Фактически не будет выведено ничего. Ниже приведена сессия в отладчике, в которой демонстрируется состояние строки после сортировки:  
![image](https://github.com/user-attachments/assets/c4745353-5c0f-499e-9584-3d86c6f1e8e5)  
Увидим, что printf не покажет, а именно, что '\0' - символ конца строки вылез в начало и из-за этого на экране мы ничего и не видим, т.к. printf выводит строки по символам пока не встретится '\0'.   

## GDB в VSCode

Все выше проделанное в консоли можно выполнять в VSCode с более удобным, современным и красивым интерфейсом.  
Для этого сначала поставим расширение в VSCode C/C++ (нужно будет найти c/c++ от microsoft, обычно первым появляется и нажать install если еще не установлен):    
![image](https://github.com/user-attachments/assets/40de18b0-21c6-4f81-b908-a13a3035fff5)  
А также установленный отладчик gdb.  
Теперь создадим конфигурационный файл для отладчика во вкладке "Run and Debug":  
![image](https://github.com/user-attachments/assets/a1831149-bd79-4c24-acef-5198ec080635)  
Выберем "create a launch.json file". Перед нами откроется почти пустой файл и появится кнопка слева снизу добавить конфигурацию (Add configuration).  
![image](https://github.com/user-attachments/assets/f1ad365f-dbcd-4596-96e8-c2bfec89e8a2)  
Выберем конфигу для (gdb) Launch:  
![image](https://github.com/user-attachments/assets/d2a5204c-aa5a-4c20-911e-c350ccbcbd61)   
Наш файл наполнится конфигурацией для запуска. Все что нам нужно, это в поле program прописать путь до исполняемого файла, например так:  
"program": "${workspaceFolder}/a.out",  или полный путь "program": "/home/kruffka/C-Programming/2024-2025/8_gdb/a.out".   
Если в нашей программе есть аргументы, то они добавляются в "args".  
Вообще дебаг конфигураций можно добавлять много и называть их по-своему, имя конфигурации пишется в "name".   
  
Соберем нашу программу ex1.c под отладкой, откроем ее в VSCode и попробуем запустить нажав зеленую стрелку во вкладке дебага:    
![image](https://github.com/user-attachments/assets/e7e1f2fb-eca6-43a8-9d57-03f4fd66899f)      

Программа отработала и ничего не произошло. Попробуем поставить точку останова (breakpoint), для этого наведем на строку мышкой и нажмем левой кнопкой мыши (ЛКМ):  
![image](https://github.com/user-attachments/assets/e257998c-dc18-464c-8fa1-315fa0a1d51f)   
Появится красная точка - это и есть наш breakpoint, теперь запустим еще раз.   
![image](https://github.com/user-attachments/assets/37b38afc-024f-49a6-b87e-0396ad4292ec)  
Наша программа остановится и мы увидим небольшую панельку сверху посередине с управлением отладки.   
А желтым цветом будет выделена строка с точкой останова.  
Кнопки на панеле выполняют все те же действия, что и команды в консоли:  
![image](https://github.com/user-attachments/assets/26e0dba3-975d-41b3-9e0d-7e855d795613) -     
![image](https://github.com/user-attachments/assets/fc3e1808-d472-4c5c-b6a8-ef0b5b6b36bf) - continue,   
![image](https://github.com/user-attachments/assets/b26c7560-adba-447b-9aa6-49a7a5323ba2) - next,  
![image](https://github.com/user-attachments/assets/b060c4f1-9365-4f5f-800d-acddb94cfa60) - step,  
![image](https://github.com/user-attachments/assets/034ebee5-81d4-40a4-98fc-def2c762d176) - run (перезапуск) и stop  

 
Сверху слева можно увидеть локальные переменные и чему они равны:   
![image](https://github.com/user-attachments/assets/99414e3d-8891-4995-9319-1c54f092179b)  
Также можно поглядеть некоторые регистры (ради интереса хотяб)    
   
Стек вызовов функций панель слева   
![image](https://github.com/user-attachments/assets/68d2f4ac-6f65-4008-a61f-d79fce3509c8)   
Можно по функциям перемещаться и смотреть локальные значения переменных конкретных функций.   

Список точек останова:   
![image](https://github.com/user-attachments/assets/ec8c07cf-732c-4c70-9504-394deb3369da)   

Если редактировать точку останова, то можно добавить условие при котором мы хотим остановиться  
![image](https://github.com/user-attachments/assets/bf0493e8-0d30-4547-9793-4717f64c84ac)  

Например поставим точку останова в 5 строке если y == 10:   
![image](https://github.com/user-attachments/assets/69bb9fc9-4253-45e9-a678-4ae02e16a143)   

Также есть debug console в VSCode:  
![image](https://github.com/user-attachments/assets/9dc7af71-2c58-452e-ba45-2e502c04135d)   
в которой можно менять значения и выводить отдельно значение некоторых переменных, пример:   
![image](https://github.com/user-attachments/assets/909ef642-a13f-496c-9797-f5abe84f84a7)   

В watch можно добавлять переменные для просмотра их значений по шагам (аналог display в консоли gdb)    
![image](https://github.com/user-attachments/assets/9e3f1a01-18eb-4c3d-ad6f-0a2a533020b7)  


Предлагаю самостоятельно повторить и закрепить отладчик на примерах 2-5 из гитхаба, используя VSCode отладчик.  
В современных реалиях чаще можно встретить VSCode отладчик чем консольный, хотя это один и тот же отладчик GDB.  
