### Ссылки

Картинки и код по односвязным спискам отсюда:
https://www.geeksforgeeks.org/linked-list-in-c/
https://www.geeksforgeeks.org/singly-linked-list-tutorial/

### Списки

**Список** — это структура данных, которая хранит элементы в линейном порядке и позволяет вставлять и удалять элементы в любом месте последовательности. Списки могут быть односвязными, двусвязными или круговыми (циклическими).

У списков разные плюсы минусы как и у всех структур данных, но одно из главных преимществ списка - быстрая вставка/удаление элементов, да и вообще возможность добавить/удалить элемент. В статическом массиве вставка/удаление новых элементов невозможна, в динамическом возможна, но нужно будет двигать все оставшиеся элементы массива, чтобы освободить место для нового элемента.


##### Таблица временной сложности 
| Параметр | Массив (статический) | Массив (динамический) | Односвязный список | Двусвязный список  |
|------|---|---|---|---|
| Доступ                | O(1)  | O(1)   | O(n)  | O(n)  |
| Вставка/Удаление в начало | --- (размер фиксированный) | O(n) (нужно двигать элементы)  | O(1) | O(1) |
| Вставка/удаление в конец           | --- (размер фиксированный) | O(1) (если есть место в массиве), O(n) (если места нет - копирование); удаление O(1)  | O(n)  | O(1) |
| Вставка/удаление в середину        | --- (размер фиксированный) | O(n) (нужно двигать элементы) | O(1) (но добираться до середины O(n)) | O(1) (но добираться до середины O(n)) |
| Поиск        | O(n)  | O(n) | O(n)  | O(n)  |



### Связанные списки (Linked List)
Связанный список представляет собой последовательность узлов, где каждый узел состоит из двух компонентов:

1. Данные: любые значения, например, число, структуры и т.д.
2. Указатель: ссылка на следующий узел в списке.

### Односвязный список в C
Односвязный список состоит из узлов. В каждом узле хранится указатель на следующий узел и сами данные. Указатели последнего узла (хвост - tail) указывают на NULL, что указывает на конец связанного списка. 

```c
struct node_s
{
    int data;
    node_t *next;
};
```

Чтобы не писать каждый раз **struct node_s** определим **node_t** через typedef
```c
typedef node_t node_t;
```

**Пример односвязного списка:**   
![alt text](img/linkedlist.png)

В отличие от массивов, связанные списки не хранят элементы в смежных ячейках памяти. Каждый узел указывает на следующий, образуя цепочечную структуру. Чтобы получить доступ к любому элементу (узлу), необходимо последовательно пройтись по всем узлам перед ним.


### Создадим свой односвязный список

Создадим указатель head, который будет указывать на начало списка:
```c
node_t* head = NULL
```
Сейчас он указывает на NULL, т.е. список пуст

### Функция по созданию нового узла

```c
// Выделяет память под новый элемент списка, зануляет указатель на следующий и присваивает значение data из аргумента data
node_t *newNode(int data) {

    node_t *new_node = (node_t *)malloc(sizeof(node_t));
    new_node->data = data;
    new_node->next = NULL;

    return new_node;
}
```

### Функция вывода всего списка
```c
// Вывод на экран списка
void printList(node_t *node) {
    
    while (node) {
        printf("%d -> ", node->data);
        node = node->next;
    }
    printf("NULL\n");
}
```

### Длина односвязного списка

```c

// Функция поиска длины списка
int lengthList(node_t* head)
{
    int length = 0;

    node_t* curr = head;
    while (curr != NULL) {
        length++;
        curr = curr->next;
    }
    return length;
}
```

### Поиск в односвязном списке

```c
// Функция поиска, проходим по списку, если элемент в списке вернем true иначе false
bool searchList(node_t* head, int target)
{
    while (head != NULL) {
        if (head->data == target) {
            return true; // Нашли
        }
        head = head->next;
    }

    return false; // Не нашли
}
```

### Функция по добавлению элемента в начало

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)

1. Создайте новый узел с заданным значением.
2. Установите следующий указатель нового узла на текущий head.
3. head должен указывать на новый узел.
4. Вернуть новую голову списка.

```c
// Функция для вставки в начало списка
node_t* appendFront(node_t* head, int data)
{
    node_t* new_node = newNode(data);
    new_node->next = head;
    head = new_node;
    // Вернем новый указатель на начало списка
    return head;
}
```

### Функция по добавлению элемента в конец

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)

1. Создать новый узел с заданным значением.
2. Проверить пуст ли список:
   1. Если да, сделать новый узел головой и вернуть
3. Перемещайтесь по списку до тех пор, пока не будет достигнут последний узел
4. Связать новый узел с текущим последним узлом, установив указатель следующего узла у последнего узла на новый узел
```c
// Функция для вставки нового элемента в конец списка
node_t* appendBack(node_t* head, int data)
{
    node_t* new_node = newNode(data);

    if (head == NULL)
        return new_node;

    node_t* curr = head;
    while (curr->next != NULL) {
        curr = curr->next;
    }

    curr->next = new_node;

    return head;
}
```

### Удаление первого узла

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)

1. Проверить, имеет ли голова значение NULL
   1. Если да, то вернуть NULL (список пуст)
2. Сохраните текущий head во временной переменной temp
3. Переместите указатель головы на следующий узел
4. Удалите временный узел
5. Вернуть новый head связанного списка

```c
// Функция по удалению первого узла
node_t* removeFront(node_t* head)
{
    if (head == NULL)
        return NULL;

    // Move the head pointer to the next node
    node_t* temp = head;
    head = head->next;

    // Free the memory of the old head
    free(temp);

    return head;
}
```
### Удаление последнего узла

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)

1. Проверить, имеет ли head значение NULL
   1. Если да, вернуть NULL (список пуст)
2. Проверить, равен ли следующий узел от головы NULL (только один узел в списке - голова)
   1. Если да, удалить head и вернуть NULL
3. Пройти по списку, чтобы найти предпоследний узел (второй_последний)
4. Удалить последний узел (узел после Second_last)
5. Установить следующий указатель предпоследнего узла в NULL
6. Возвращаем head списка

```c
// Функция удаляет последний узел списка
node_t* removeLastNode(node_t* head)
{
    if (head == NULL)
        return NULL;

    if (head->next == NULL) {
        free(head);
        return NULL;
    }

    node_t* second_last = head;
    while (second_last->next->next != NULL)
        second_last = second_last->next;

    free(second_last->next);
    second_last->next = NULL;

    return head;
}
```

### Вставка в середину и удаление из середины

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)

![alt text](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)

### Очередь

FIFO
методы enqueue, dequeue

### Стек

LIFO 
методы push, pop



### Многосвязный список

## Todo Картинки и текст
```c
// Многосвязный список
node_t {
    node_t *prev;
    int data;
    node_t *next;
};
```

Создать узел

Связать узлы

## Циклический список


 