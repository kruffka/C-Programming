## Процессы и потоки   

<img src="img/cookies.png" width ="300"><img src="img/thread_g.png" width ="300">         

**thread - поток - нить**    
### Теория

Возьмем определение из вики:   
**Многопото́чность** (англ. **Multithreading**) — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.  

Многопоточность позволяет программе выполнять несколько задач одновременно. Например, когда вы используете веб-браузер: Один поток загружает содержимое веб-страницы (текст, изображения, видео), в то время как другой поток реагирует на ваши действия, такие как движение мыши или прокрутка страницы. Такая многозадачность делает браузер плавным и отзывчивым. Если потоки не используются, браузер может зависать и ждать завершения одной задачи, прежде чем приступить к следующей. Потоки обеспечивают плавность, скорость и отзывчивость работы программы.    

Здесь, пока далеко не ушли, следует вспомнить курс по ОС и понятие процесса, чтобы понимать разницу между процессом и потоком. **Описание и картинки ниже относятся конкретно к Linux, в других ОС реализация может отличаться, но смысл примерно тот же**         

**Процессы** — это программы, которые выполняются на CPU. Процесс требует больше времени для завершения и изолирован от других процессов, что означает, что он не разделяет с ними память.    

Процессы в Linux могут принимать следующие состояния:
![alt text](img/proc_states.png)  

- Running or Runnable (R)
- Uninterruptible Sleep (D)
- Interruptable Sleep (S)
- Stopped (T)
- Zombie (Z)

В общих чертах процесс состоит из:    
![alt text](img/process.png)
- Identifying information (e.g. process ID and user ID)
- Environment variables
- Working directory
- Program instructions
- CPU state (e.g. registers, fault info)
- Memory allocation (stack and heap)
- File descriptors
- Signal actions
- Shared libraries
- Inter-process communication related information (such as message queues, pipes, semaphores, or shared memory).
    
**Потоки** часто называют «легковесными процессами» (lightweight process), потому что они разделяют некоторые черты процессов, но меньше и быстрее. Каждый поток всегда является частью одного определенного процесса. Поток может находиться в следующих состояниях: Выполняется, Готов, Заблокирован, Сон.    
    
Как поток лежит внутри процесса:    
![alt text](img/thread.png)
- Stack pointer
- Registers
- Scheduling properties (such as policy or priority)
- Set of pending and blocked signals
- Thread-specific data
   
Короче говоря процесс очень тяжелая штука и на самом деле это очень здоровенная структура данных и плодить кучу таких будет дорого для системы. Процессы между собой не разделяют память, у каждого она своя. У потоков наоборот, потоки разделяют между собой память т.к. находятся внутри одного процесса.    

Картинки про процессы и потоки на Linux отсюда     
https://hpc-tutorials.llnl.gov/posix/what_is_a_thread/        

Потоки существуют только в контексте процесса. Потоки могут порождать другие потоки и владеть ими, но владеть процессом они не смогут. Даже если вызвать 'fork()' из потока, вся власть над процессом будет у родительского процесса потока. Процессы могут порождать другие процессы с помощью функции **`fork()`**, которые известны как дочерние процессы. Родительский и дочерний процессы различаются по **PID (Process ID)**.

При создании процесса через fork по сути происходит клонирование родительского процесса со всеми его данными и такое копирование на самом деле затрано. Поэтому придумали хитрый метод **Copy-On-Write** (подробнее в гугле или [например тут](https://cpu.land/lets-talk-about-forks-and-cows)), который избегает этих расходов, будучи ленивым: Вместо того, чтобы копировать всю память сразу, он делает вид, что она была скопирована, и фактически копирует только тогда, когда родителю или потомку нужно хранить разные значения по одному и тому же адресу     

**Если вкратце в среде UNIX, то процесс — это выполняемая программа, тогда как поток:**
- Существует внутри процесса и использует ресурсы процесса
- Работает пока жив родительский поток
- Дублирует только основные ресурсы, которые ему нужны для независимого планирования, что делает его легким
- Может совместно использовать ресурсы процесса с другими потоками

**Поскольку потоки в одном процессе совместно используют ресурсы:**
- Изменения, внесенные одним потоком в общие системные ресурсы (например, закрытие файла), будут видны всем другим потокам
- Два указателя с одинаковым значением указывают на одни и те же данные
- Возможно чтение и запись в одни и те же области памяти, поэтому требуется явная синхронизация со стороны программиста     

![alt text](./img/os_proc_thread.png)

### CPU и ядра

![alt text](img/cpu.png)

Все наши и не наши программы выполняются на процессоре. В современных реалиях везде используются многоядерные процессоры, т.е. процессоры содержащие 2 и более ядра на одном камне или в одном корпусе. Каждый из таких ядер может выполнять одновременно с другими выполнять задачи.    

Узнать количество ядер на нашей системе можно через командную строку (на любой OS) или диспетчер задач (на windows)    
Например в Linux можно через lscpu увидеть всю информацию о процессоре:
```bash
Architecture:             x86_64
  CPU op-mode(s):         32-bit, 64-bit
  Address sizes:          46 bits physical, 48 bits virtual
  Byte Order:             Little Endian
CPU(s):                   16
  On-line CPU(s) list:    0-15
Vendor ID:                GenuineIntel
  Model name:             12th Gen Intel(R) Core(TM) i5-12600K
    CPU family:           6
    Model:                151
    Thread(s) per core:   2
    Core(s) per socket:   8
    Socket(s):            1
    Stepping:             2
    BogoMIPS:             7372.79
    Flags:                ...
```    
В ней мы можем увидеть информацию об архитектуре процессора (x86_64 - x86 архитектура и 64 разрядная). Порядок байт - Little Endian. Количество процос (socket) = 1, количество ядер = 8, количество потоков на ядро = 2. Итого можно сказать, что одновременно процессор сможет потянуть 1*8*2 потоков со своими задачами. Но на практике конечно зависит от сценария. Физических ядер 8, т.е. это 8 ядер внутри одного CPU, которые что-то выполняют, логические ядра - не физические, их не существует, логические ядра придумала компания Intel, разработав технологию Гиперпоточности (Hyper-Threading или HT, у AMD процов аналог - SMT), если вкратце, то работает следующим образом: ядро хранит в себе состояние сразу двух потоков (регистры и т.д.) и для ОС это выглядит как два логических ядра. И таким образом если одно из логических ядер по той или иной причине находится в ожидании, второе логическое начинает работать, а также инструкции с обоих логических ядер могут перемешиваться и выполняться одновременно.    


![alt text](img/logical.png)
     
В былые времена было лишь одно ядро. И чтобы ОС не зависала на выполнении одной программы инженеры подумали и реализовали следующее: процессоры выполняют очень-очень много инструкций за одну секунду и для человека будет незаметно если его программа не будет выполняться малую долю секунды, почему бы не взять и не разделить время выполнения программ на процессоре так, что каждой программе будет доставаться определенный кусочек времени процессора, т.е. проц будет очень быстро переключаться между потоками. Таким образом на одном ядре была достигнута "параллельность" выполнения. Современные процессоры выполняют миллиарды операций в секунду и такой подход все также остался с нами. Такой задачей занимается планировщик (scheduler, он же диспетчер задач) ОС. И в таком случае программы конкурируют за время процессора.        

Вообще тема процессоров довольно интересная:
Современные процессоры нереально сложная штука: необходимы очень нежные условия расположения завода, где из песка роботизированные машины месяцами работают над процессорами и очень большая часть из них после производства дефектные (80-95% дефектных для некоторых моделей у Intel).     

####

Когда рассказывают про параллельные вещи, то обычно также упоминают эти два термина:      
- **Конкурентность** - это выполнение задач за определённое время     
![alt text](img/concurency.png)

- **Параллелизм** - это одновременное выполнение нескольких действий     
![alt text](./img/parallel.png)


### Pthread

Для написания многопоточных программ мы с вами познакомимся с POSIX API, где  
**POSIX (Portable Operating System Interface)** — это семейство стандартов, определяющих общий набор API для Unix-подобных операционных систем (Ubuntu, MacOs и прочие). Для Windows есть свой API для потоков - Win API, отличаются функции, но смысл все тот же.    
Конкретно из POSIX нас интересует классическая библиотека для разработки многопоточных приложений - **pthread**. На Windows его тоже можно использовать если установить библиотеку pthread        

#### Первая многопоточная программа

Не забываем слинковать с библиотекой pthread: -lpthread    

Мануал: 
```bash
man pthreads
```

[Знакомимся с pthread](https://github.com/kruffka/C-Programming/blob/master/2024-2025/multithreading/src/hello_thread.c)

**pthread_create()** - создать поток. Порядок запуска потоков из pthread_create случайный - определяет диспетчер задач (планировщик). Функция не блокирующая     
**pthread_join()** - объединить две нити в одну как в этой замечательной картинке снизу из paint. Блокирующая функция     
![alt text](img/join.png)    

[Передача аргументов и возврат из потока значения](https://github.com/kruffka/C-Programming/blob/master/2024-2025/multithreading/src/thread_arg.c)

[Одна из проблем с не внимательной передачей аргумента](https://github.com/kruffka/C-Programming/blob/master/2024-2025/multithreading/src/thread_arg2.c)


#### Примитивы синхронизации

Начнем с классического мьютекса (Mutex = Mutual exclusion - взаимное исключение)     

Операция в общей области памяти называется **атомарной**, если она завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Тоесть если несколько потоков одновременно обратятся к такой атомарной операции, то гарантированно выполнится в один момент времени лишь одна из них.    

**Критическая секция** — участок исполняемого кода программы, в котором производится доступ к общему ресурсу, который не должен быть одновременно использован более чем одним потоком выполнения. При нахождении в критической секции двух потоков возникает состояние «гонки» (**race condition**).        

![alt text](img/race_cond.png)    
   
[Пример гонки потоков](https://github.com/kruffka/C-Programming/blob/master/2024-2025/multithreading/src/race_condition.c)       

[Пример с mutex]([2024-2025/multithreading/src/mutex.c](https://github.com/kruffka/C-Programming/blob/master/2024-2025/multithreading/src/slow_mutex.c))     


И еще много всего.. todo ...