## Немного предислов

C++ как и Си - язык статической типизации (не динамической как python), компилируемый, а также управляем в нем выделением и освобождением памяти ручками
При изучении C++ сначала стоит уделить внимание самым основам, потом

Познавать С++ можно с классики - «Язык программирования C++» (The C++ Programming Language) Бьерн Страуструп, он же создатель языка С++, дальше углубиться в ООП, STL, можно посмотреть потоки, а в конце изучать фишки стандартов C++11/17/20/23, там появляется всякая move-семантика, корутины и т.д..

Также для начинающих неплохой материал: https://education.yandex.ru/handbook/cpp

## Примеры
Начнем с хелло ворлд и пробежимся хотя бы до векторов и умных указателей

### Hello, world..

```cpp
#include <iostream>

int main() {

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
```
где
**<<** - оператор вставки, который передает данные в cout
Для ввода с клавиатуры используется cin и **>>**.    
**std::** - стандартное пространство имен, можно не писать если использовать 
```cpp
using namespace std;
```
но такое не рекомендуется использовать в больших проектах из-за возможного конфликта с этими именами и их внутренностями

### Переменные

Такие же как в Си и объявляются точно также, но есть в стандартной библиотеке другие типы данных, например вместо массива char есть string:

```c++
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::getline(std::cin, name);
    std::cout << "Hello, " << name << "!\n";
}
```

Пример ввода и вывода нескольких переменных:
```c++
int main() {
    int a;
    int b;
    int c;
    std::cin >> a >> b >> c;
    std::cout << a << " " << b << " " << c << "\n";
}
```

В отличии от C, где auto - это просто int, в C++ auto определяет сам тип переменной из численной константы
```c++
int main() {
    auto x = 42;  // int
    auto pi = 3.14159;  // double
}
```

Явные преобразования типов здесь очень разные - посмотреть самостоятельно, вот один из них:

```c++
double d = 3.14;
int i = static_cast<int>(d); // явно преобразуем double = 3.14 в int = 3
```

### Циклы и условия

Тут можно все как в Си, например:

```cpp
for (int i = 0; i < 100; i++) {
    if (i % 2 == 0) {
        std::cout << i << " is even\n";
    }
}
```

А можно сделать так (с версии C++11 и новее):

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto num : vec) {
    std::cout << num << " ";
}
```
где vec - вектор,
auto - автоматическое определение типа данных


### Векторы

В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти.      

Векторы и строки также называют контейнерными типами (хранит и обрабатывает разные объекты)

```c++
#include <vector>

int main() {

    std::vector<int> data = {1, 2, 3, 4, 5}; // вектор из целых чисел
    std::vector<std::string> empty_vec;  // пустой вектор строк
    std::vector<std::string> str_vec(5);  // вектор из пяти пустых строк
    std::vector<std::string> str_hellos(5, "hello");  // вектор из пяти строк "hello"

    int first = data[0];  // первый элемент вектора
    int last = data[4];  // первый элемент вектора
    int buf_overflow = data[5];  // переполнение буфера
    data[2] = 42;  // меняем элемент 3 на 42

    std::cout << data.size() << "\n"; // Количество элементов в векторе

    return 0;
}
```

Методы: 
- push_back() — добавление в конец.
- pop_back() — удаление последнего элемента.
- front(), back() - взять элементы с начала или с конца
- size(), empty() — проверка размера.
- [] и at() — доступ по индексу, где at() делает проверки на переполнение и выдает исключения

Пример с front() и back()
```c++
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data.front() << "\n";  // == data[0]
std::cout << data.back() << "\n";  //  == data[data.size() - 1]
```

Пример с push_back()
```c++
#include <iostream>
#include <vector>

int main() {
    int x;
    std::vector<int> data;
    while (std::cin >> x) {  // читаем числа, пока не закончится ввод
        data.push_back(x);  // добавляем очередное число в вектор
    }

    while (!data.empty() && data.back() == 0) {
        // Пока вектор не пуст и последний элемент равен нулю
        data.pop_back();  // удаляем этот нулевой элемент
    }
}
```

![alt text](./img/capacity.png)

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2};
    for (int i = 0; i < 16; i++) {
        std::cout << "[" << i << "] " << vec.size() << "\t" << vec.capacity() << "\n";
        vec.push_back(i);
    }

}
```

Размер при добавлении элементов выделяется заранее, но если элементы будут постоянно добавляться, то vector будет делать реаллокацию (realloc как в Си), что может быть не очень дешево и сердито      

Можно заранее выделить памяти под некоторое количество элементов через метод reserve()


#### Векторы векторов (матрицы)

```c++
#include <iostream>
#include <vector>

int main() {
    size_t m = 5, n = 5;

    // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));

    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    // напечатаем матрицу, выводя элементы через табуляцию
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << "\n";
    }
}
```


### Функции

Перегрузка функций

```cpp
int sum(int a, int b) {
    return a + b;
}
double sum(double a, double b) {
    return a + b;
}
```

Функции могут возвращать вектора!

А можно вообще так:
```cpp
template <typename T>
T sum(T a, T b) {
    return a + b;
}
```
это называется шаблоном и позволяет использовать разные типы данных


### Итераторы

### ООП

### Стандартная библиотека STL
