## Немного предислов

C++ как и Си - язык статической типизации (не динамической как python), компилируемый. Управление дин.памятью в ручное

Познавать С++ нужно с классики - «Язык программирования C++» (The C++ Programming Language) Бьерн Страуструп, он же создатель языка С++, дальше углубиться в ООП, STL (которые также в этой книге и в куче онлайн курсов описываются), опционально посмотреть потоки, а в конце изучать новвоведения и фишки стандартов C++11/17/20/23. Там появляется всякая move-семантика, корутины и т.д..

Также для начинающих неплохой материал: https://education.yandex.ru/handbook/cpp
И для тех кто хочет основы синтаксиса C++ пробежать можно глянуть w3school C++ курсы

Далее идем и набиваем руку на leetcode/codeforces
Неплохо затем почитать книги по современному C++ (в архиве в эиосе находим либо в интернете)
и где его используют, чтобы копать и практиковаться в понравившейся теме, например (CUDA, в Qt разработке, в играх и т.д..)

## Примеры
Начнем с хелло ворлд и пробежимся хотя бы до векторов и умных указателей

### Hello, world..

```cpp
#include <iostream>

int main() {

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
```
где
**<<** - оператор вставки, который передает данные в cout
Для ввода с клавиатуры используется cin и **>>**.    
**std::** - стандартное пространство имен, можно не писать если использовать 
```cpp
using namespace std;
```
но такое не рекомендуется использовать в больших проектах из-за возможного конфликта с этими именами и их внутренностями

```cpp
using Complex = std::complex<double>;
```
А такая штука похожа на typedef, только в стиле C++ и означает, что вместо слова Complex будет подставляться std::complex<double>

### Переменные

Такие же как в Си и объявляются точно также, но есть в стандартной библиотеке другие типы данных, например вместо массива char есть string:

```c++
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::getline(std::cin, name);
    std::cout << "Hello, " << name << "!\n";
}
```

Пример ввода и вывода нескольких переменных:
```c++
int main() {
    int a;
    int b;
    int c;
    std::cin >> a >> b >> c;
    std::cout << a << " " << b << " " << c << "\n";
}
```

В отличии от C, где auto - это просто int, в C++ auto определяет сам тип переменной из численной константы
```c++
int main() {
    auto x = 42;  // int
    auto pi = 3.14159;  // double
}
```

Явные преобразования типов здесь очень разные - посмотреть самостоятельно, вот один из них:

```c++
double d = 3.14;
int i = static_cast<int>(d); // явно преобразуем double = 3.14 в int = 3
```

### Циклы и условия

Тут можно все как в Си, например:

```cpp
for (int i = 0; i < 100; i++) {
    if (i % 2 == 0) {
        std::cout << i << " is even\n";
    }
}
```

А можно сделать так (с версии C++11 и новее):

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto num : vec) {
    std::cout << num << " ";
}
```
где vec - вектор,
auto - автоматическое определение типа данных


### Векторы

В стандартной библиотеке C++ вектором (std::vector) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти.      

Векторы и строки также называют контейнерными типами (хранит и обрабатывает разные объекты, т.е. что-то типа массива каких-то типов данных)

```c++
#include <vector>

int main() {

    std::vector<int> data = {1, 2, 3, 4, 5}; // вектор из целых чисел
    std::vector<std::string> empty_vec;  // пустой вектор строк
    std::vector<std::string> str_vec(5);  // вектор из пяти пустых строк
    std::vector<std::string> str_hellos(5, "hello");  // вектор из пяти строк "hello"

    int first = data[0];  // первый элемент вектора
    int last = data[4];  // первый элемент вектора
    int buf_overflow = data[5];  // переполнение буфера
    data[2] = 42;  // меняем элемент 3 на 42

    std::cout << data.size() << "\n"; // Количество элементов в векторе

    return 0;
}
```

Методы: 
- push_back() — добавление в конец.
- pop_back() — удаление последнего элемента.
- front(), back() - взять элементы с начала или с конца
- size(), empty() — проверка размера.
- [] и at() — доступ по индексу, где at() делает проверки на переполнение и выдает исключения

Пример с front() и back()
```c++
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data.front() << "\n";  // == data[0]
std::cout << data.back() << "\n";  //  == data[data.size() - 1]
```

Пример с push_back()
```c++
#include <iostream>
#include <vector>

int main() {
    int x;
    std::vector<int> data;
    while (std::cin >> x) {  // читаем числа, пока не закончится ввод
        data.push_back(x);  // добавляем очередное число в вектор
    }

    while (!data.empty() && data.back() == 0) {
        // Пока вектор не пуст и последний элемент равен нулю
        data.pop_back();  // удаляем этот нулевой элемент
    }
}
```

![alt text](./img/capacity.png)

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2};
    for (int i = 0; i < 16; i++) {
        std::cout << "[" << i << "] " << vec.size() << "\t" << vec.capacity() << "\n";
        vec.push_back(i);
    }

}
```

Размер при добавлении элементов выделяется заранее, но если элементы будут постоянно добавляться, то vector будет делать реаллокацию (realloc как в Си), что может быть не очень дешево и сердито      

Можно заранее выделить памяти под некоторое количество элементов через метод reserve()


#### Векторы векторов (матрицы)

```c++
#include <iostream>
#include <vector>

int main() {
    size_t m = 5, n = 5;

    // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));

    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    // напечатаем матрицу, выводя элементы через табуляцию
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << "\n";
    }
}
```


### Функции

Перегрузка функций

```cpp
int sum(int a, int b) {
    return a + b;
}
double sum(double a, double b) {
    return a + b;
}
```

Функции могут возвращать вектора!

А можно вообще так:
```cpp
template <typename T>
T sum(T a, T b) {
    return a + b;
}
```
это называется шаблоном и позволяет использовать разные типы данных


### Копмлексные числа

В станртной либе есть тип данных комплексные числа, примерчик:
```cpp
#include <complex>
#include <iostream>

using Complex = std::complex<double>;  // Определяем псевдоним

int main() {
    Complex z1 = 3.0 + 4.0j;  // Complex вместо std::complex<double>
    Complex z2(2.5, -1.5); // конструктор

    std::cout << "z1 = " << z1 << "\n";
    std::cout << "z2 = " << z2 << "\n";
    std::cout << "z1 + z2 = " << z1 + z2 << "\n";

    return 0;
}
```

### Указатели и ссылки

Здесь есть обычные указатели как в Си, но есть еще и понятие ссылки      

```c++
int x = 10;
int *ptr = &x; // берем адрес x и записываем в указатель ptr
*ptr = 20; // разыменовываем
```

#### Ссылки

Используют обычно для передачи в функцию аргументов или возвращения результата     

Ссылки в C++ - это механизм, который позволяет создавать альтернативные имена (псевдонимы) для существующих переменных.   
```c++
int x = 10;
int& ref = x;  // ref - это ссылка на x
ref = 20;      // изменяем x через ссылку
```

- Должны быть инициализированы при объявлении
- Указывают всегда на один объект
- Не могут быть null (в отличие от указателей)

```c++
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int x = 1, y = 2;
swap(x, y);  // x и y поменяются местами
```

Чаще всего эти ссылки используются для передачи переменных по адресу в функции, чтобы не заниматься копированием, но без разыменований как в указателях. Можно думать, что ссылка — это указатель, который сам, автоматически, применяет разыменование (dereference)


ой-ой-ой:
```cpp
int& getMax(int& a, int& b) {
    return a > b ? a : b;
}

int x = 5, y = 3;
getMax(x, y) = 10;  // изменяет x на 10
```

```cpp
std::vector<int> vec = {1, 2, 3};
for (int& num : vec) {
    num *= 2;  // изменяем элементы вектора
}
```
| Характеристика      | References (Ссылки)                          | Pointers (Указатели)                     |
|---------------------|---------------------------------------------|------------------------------------------|
| Reassignment        | Не могут быть переназначены                | Могут быть переназначены                |
| Memory Address      | Используют тот же адрес, что и оригинальная переменная | Имеют собственный адрес памяти         |
| Work               | Являются псевдонимом другой переменной    | Хранят адрес переменной                |
| Null Value         | Не могут иметь значение null              | Могут иметь значение null              |
| Arguments          | Передаются по значению (method pass by value) | Передаются по ссылке (method pass by reference) |


#### Итераторы

#### Умные указатели

### ООП немножко

### Стандартная библиотека STL
